const cds = require('../cds');
const DEBUG = cds.log('cli')._debug

const cfUtil = require('../util/cf');
const { bold } = require('../util/term');
const { mergeCredentials } = require('./index');

module.exports = new class CFKeyProvider {
    async init() {
        if (!this.target) {
            this.target = await cfUtil.getCfSpaceInfo();
        }
    }

    async getOrg(orgName) {
        const result = await cfUtil.cfRequest('/v3/organizations', { names: orgName });
        return result?.resources?.[0];
    }

    async getSpace(orgGuid, spaceName) {
        const result = await cfUtil.cfRequest('/v3/spaces', { names: spaceName, organization_guids: orgGuid });
        return result?.resources?.find(r => r.relationships.organization.data.guid === orgGuid);
    }

    async getInstance(spaceGuid, instanceName) {
        const result = await cfUtil.cfRequest('/v3/service_instances', { names: instanceName, space_guids: spaceGuid });
        return result?.resources?.find(r => !!r.relationships.space.data.guid);
    }

    async getPlan(planGuid) {
        const result = await cfUtil.cfRequest('/v3/service_plans', { guids: planGuid });
        return result?.resources?.[0];
    }

    async getOffering(offeringGuid) {
        const result = await cfUtil.cfRequest('/v3/service_offerings', { guids: offeringGuid });
        return result?.resources?.[0];
    }

    async resolve(name, binding) {
        await this.init();
        this._checkApiEndpoint(name, binding)

        let { instance, org, space } = binding;
        let spaceGuid, orgGuid;
        if (org && space) {
            // org and space can be overwritten by currently logged in org and space
            const orgObj = await this.getOrg(org);
            const spaceObj = await this.getSpace(orgObj.guid, space);
            spaceGuid = spaceObj.guid;
            orgGuid = orgObj.guid;
        } else {
            org = this.target.org;
            space = this.target.space;
            spaceGuid = this.target.spaceGuid;
            orgGuid = this.target.orgGuid;
        }

        let instanceObj;
        try {
            instanceObj = await this.getInstance(spaceGuid, instance);
            const instanceSpaceGuid = instanceObj.relationships.space.data.guid;
            if (instanceSpaceGuid !== spaceGuid) {
                // service instance is shared from another space, service key must be created in that space
                const sharedFromSpaceObj = await cfUtil.cfRequest('/v3/spaces/' + encodeURIComponent(instanceSpaceGuid));
                space = sharedFromSpaceObj.name;
                spaceGuid = sharedFromSpaceObj.guid;
                const instanceOrgGuid = sharedFromSpaceObj.relationships.organization.data.guid;
                if (instanceOrgGuid !== orgGuid) {
                    const sharedFromOrgObj = await cfUtil.cfRequest('/v3/organizations/' + encodeURIComponent(instanceOrgGuid));
                    org = sharedFromOrgObj.name;
                    orgGuid = sharedFromOrgObj.guid;
                }
            }
        } catch (error) {
            throw `Service instance ${bold(instance)} not found.`;
        }
        switch (instanceObj.type) {
            case 'managed':
                return this._resolveManagedService(instanceObj, instance, binding.key || `${instance}-key`, org, space, binding.credentials);
            case 'user-provided':
                return this._resolveUserProvidedService(instanceObj, instance, org, space, binding.credentials);
            default:
                throw `Service type ${bold(instanceObj.type)} not supported`;
        }
    }

    async _resolveManagedService(instanceObj, instance, key, org, space, customCredentials) {
        const create = (cds.cli.command === 'bind' || cds.cli.command === 'deploy') && !cds.cli.options['no-create-service-key']
        const silent = (cds.cli.options.json || cds.cli.command === 'env') && !DEBUG
        const credentials = await cfUtil.getOrCreateServiceKey(instanceObj, key, {}, { create, silent });

        if (!credentials) {
            let message = `No service key ${bold(key)} found for service instance ${bold(instance)}.\n\n`;
            message += `Use ${bold(`cf create-service-key ${instanceObj.name} ${key} [-c ...]`)} to create the required service key.`;
            throw message;
        }

        const planObj = await this.getPlan(instanceObj.relationships.service_plan.data.guid);
        const offeringObj = await this.getOffering(planObj.relationships.service_offering.data.guid);
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: this.target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                key: key,
                vcap: {
                    label: offeringObj.name,
                    plan: planObj.name,
                    tags: offeringObj.tags
                },
                resolved: true,
            },
            credentials: mergeCredentials(credentials, customCredentials)
        };

        return resolvedBinding;
    }

    async _resolveUserProvidedService(instanceObj, instance, org, space, customCredentials) {
        const credentials = await cfUtil.cfRequest(`/v3/service_instances/${encodeURIComponent(instanceObj.guid)}/credentials`);
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: this.target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                vcap: {
                    label: instanceObj.type,
                    tags: instanceObj.tags
                },
                resolved: true,
            },
            credentials: mergeCredentials(credentials, customCredentials)
        };
        return resolvedBinding;
    }

    _checkApiEndpoint(name, binding) {
        const { apiEndpoint, key, instance } = binding

        // if no api endpoint is configured the currently logged in endpoint will be used
        if (apiEndpoint && apiEndpoint !== this.target.apiEndpoint) {
            name = `${name || instance}:${key || instance + '-key'}`;
            let message = `Current Cloud Foundry API endpoint ${bold(this.target.apiEndpoint)} differs from API endpoint ${bold(apiEndpoint)} for service binding ${bold(name)}.\n\n`;
            message += `Use ${bold(`cf login -a ${apiEndpoint}`)} to log in to the target API endpoint.`;
            throw message;
        }
    }
}
