const cds = require('../cds');

const BindingResolver = require('./bindingResolver');
const { determineKinds, getRequiresNameFromKind, checkIsJavaProject, platformText, bindingText, logger } = require('./bindingUtil');
const { bold } = require('../util/term');


module.exports = { bind, storeBindings, parseProfile, mergeCredentials }

/**
 * Executes cds build in the directory defined by cds.root.
 *
 * @param {object} options - command options as defined by build command.
 */
async function bind(options) {
    let on;
    switch (options.on) {
        case 'k8s':
        case 'kubernetes':
            on = 'k8s';
            break;
        case undefined:
        case null:
        case 'cf':
        case 'cloudfoundry':
            on = 'cf';
            break;
        default:
            throw `Invalid value '${options.on}' for option --on.`;
    }

    const onText = { 'cf': 'Cloud Foundry', 'k8s': 'Kubernetes' }[on];
    if (!options['to-app-services']) logger.log(`Retrieving data from ${bold(onText)}...`);

    // run in parallel
    const targets = options.to.split(/,/g);
    const resolvedServices = await Promise.all(targets.map(async target => {
        let binding;
        if (on === 'k8s') {
            binding = { type: on, name: target };
        } else if (on === 'cf') {
            const [instance, key] = target.split(/:/);
            binding = { type: on, instance, key };
        } else {
            throw new Error('Internal Error');
        }
        const resolvedService = await BindingResolver.resolveBinding(undefined, binding);
        resolvedService._target = target;
        delete resolvedService.credentials;
        resolvedService.binding.resolved = false;
        return resolvedService;
    }));

    if (options.kind) {
        resolvedServices.forEach(service => service.kind = options.kind);
    } else {
        determineKinds(resolvedServices);
    }

    for (const resolvedService of resolvedServices) {
        if (options.serviceArg) {
            resolvedService.name = options.serviceArg;
        } else if (resolvedService.kind) {
            resolvedService.name = getRequiresNameFromKind(resolvedService.binding.instance, resolvedService.kind);
        }

        let { kind, name, binding } = resolvedService;
        name = name ?? `custom-service:${binding.instance || binding.secret}`
        resolvedService.name = resolvedService.name ?? name
        const kindText = kind ? ` with kind ${bold(kind)}` : ''
        const nameText = bold(name)

        logger.log(`Binding ${nameText} to ${platformText(binding)} ${bindingText(binding)}${kindText}`);
    }

    return resolvedServices;
}

async function storeBindings(resolvedServices, options) {
    // prepare for different providers
    const userCdsrcJsonStorageProvider = require('./userCdsrcJsonStorageProvider');

    await userCdsrcJsonStorageProvider.storeServices(resolvedServices, {
        ...options
    });

    const isJavaProject = await checkIsJavaProject(cds.root);
    if (!cds.cli.options['to-app-services']) {
        logger.log(`\nTo run with cloud bindings use ${bold(runCmd(options.for, isJavaProject))}`);
    }
}

function runCmd(profile, isJavaProject) {
    profile = parseProfile(profile);
    if (isJavaProject) {
        const p = profile === 'hybrid' ? '' : ` --profile ${profile}`;
        return `cds bind --exec${p} mvn spring-boot:run`;
    } else {
        const p = profile === 'development' ? '' : ` --profile ${profile}`;
        return `cds watch${p}`;
    }
}

function parseProfile(profile) {
    if (!profile) return 'hybrid';
    else if (profile === '-') return 'development';
    else return profile;
}

function mergeCredentials(credentials, customCredentials) {
    if (!customCredentials) return credentials;

    for (const key in customCredentials) {
        if (typeof customCredentials[key] === 'object') {
            if (credentials[key] && typeof credentials[key] !== 'object') {
                throw `Cannot merge credentials: '${key}' is not an object`;
            }
            if (!credentials[key]) {
                credentials[key] = {};
            }
            credentials[key] = this._mergeCredentials(credentials[key], customCredentials[key]);
        } else {
            credentials[key] = customCredentials[key];
        }
    }
    return credentials;
}
