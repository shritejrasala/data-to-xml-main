const { yaml } = require('../cds').utils
const { execSync } = require('child_process');
const { bold } = require('../util/term');

class KubernetesApiAccessor {

    constructor() {

        this.config = once( async() => {
            const configString = execSync('kubectl config view --raw').toString();
            const config = yaml.parse(configString);

            const currentContextName = config['current-context'];
            if (!currentContextName) throw new Error(`No current context in kubectl config.`);
            const currentContextEntry = config.contexts && config.contexts.find( entry => entry.name === currentContextName && entry.context && entry.context.cluster && entry.context.user );
            if (!currentContextEntry) throw new Error(`Current context not found in kubectl config.`);
            const currentContext = currentContextEntry.context;
            const clusterEntry = config.clusters && config.clusters.find( entry => entry.name === currentContext.cluster && entry.cluster && entry.cluster.server );
            if (!currentContextEntry) throw new Error(`Cluster ${bold(currentContext.cluster)} not found in kubectl config.`);
            const { cluster } = clusterEntry;

            const serverToContext = {};
            for (const clusterEntry of config.clusters) {
                const contextEntries = config.contexts.filter( contextEntry => contextEntry.context.cluster === clusterEntry.name );
                // Collect only cluster servers that are used in exactly one context, to clearly identify the context to be used
                if (contextEntries.length === 1) {
                    serverToContext[clusterEntry.cluster.server] = contextEntries[0];
                }
            }

            return {
                namespace: currentContext.namespace || 'default',
                context: currentContextEntry,
                cluster,
                serverToContext
            }
        });
    }

    async context({cluster, namespace}) {
        const config = await this.config();
        let contextEntry;

        if (cluster && cluster !== config.cluster.server) {
            contextEntry = config.serverToContext[cluster] || throwError(`Cluster ${bold(cluster)} not found in kubectl configuration`);
        } else {
            contextEntry = config.context;
        }

        return {
            context: contextEntry.name,
            cluster: cluster || config.cluster.server,
            namespace: namespace || contextEntry.context.namespace || 'default'
        };
    }

    async get(options) {
        const {context, namespace, kind, name} = options;
        try {
            return JSON.parse(execSync(`kubectl --output json --context ${context} --namespace ${namespace} get ${kind} ${name}`).toString());
          }
          catch (error) {
            if (error.status === 1) return null
            else throw error
        }
    }
}

function once(func) {
    let result;
    return function(...args) {
        if (!result) result = func(...args);
        return result;
    }
}

function throwError(msg = 'Internal Error') {
    throw new Error(msg);
}

module.exports = KubernetesApiAccessor;
