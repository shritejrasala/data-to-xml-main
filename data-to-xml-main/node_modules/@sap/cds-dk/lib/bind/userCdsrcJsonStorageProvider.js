const os = require('os');
const path = require('path');
const readline = require('readline');

const fs = require('fs').promises;
const { bold } = require('../util/term');
const { logger } = require('./bindingUtil');

const gitUtil = require('../util/git');

const CDSRC_FILENAME = '.cdsrc-private.json';

class UserCdsrcJsonStorageProvider {
    async askBooleanQuestion(question) {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        question = question.trim() + ' ';
        return new Promise(resolve => {
            rl.question(question, answer => {
                if (answer === 'y' || answer === 'Y') {
                    resolve(true);
                } else {
                    resolve(false);
                }
                rl.close();
            });
        });
    }

    async storeServices(services, options = {}) {
        let jsonPath = options.out || CDSRC_FILENAME;

        if (jsonPath === CDSRC_FILENAME) {
            await gitUtil.ensureFileIsGitignored(CDSRC_FILENAME);
        }

        jsonPath = jsonPath.replace(/~/g, os.homedir());
        if (path.extname(jsonPath) !== '.json') {
            jsonPath = path.join(jsonPath, '.cdsrc.json');
        }

        const jsonObject = await this.readJsonSafely(jsonPath);
        let cdsRoot;
        if (path.basename(jsonPath) === 'package.json') {
            jsonObject.cds = jsonObject.cds || {};
            cdsRoot = jsonObject.cds;
        } else {
            cdsRoot = jsonObject;
        }

        const profileKey = `[${options.for}]`;
        const features = cdsRoot.features && cdsRoot.features[profileKey];
        if (features) delete features.emulate_vcap_services;

        cdsRoot.requires = cdsRoot.requires || {};
        let section;
        section = cdsRoot.requires[profileKey] = cdsRoot.requires[profileKey] || {};

        for (const service of services) {
            const { name, kind, binding, credentials } = service;
            const requireService = section[name] = section[name] || {};
            // store optional custom credentials
            binding.credentials = this._getServiceCredentials(binding, services, options);

            Object.assign(requireService, { binding: { ...binding, vcap: undefined }, credentials, kind, vcap: { name } });
        }

        await this.writeJsonFile(jsonPath, jsonObject);
        logger.log(`Saving bindings to ${bold(jsonPath)} in profile ${bold(options.for)}`);
    }

    async readJsonSafely(filePath) {
        try {
            return JSON.parse(await fs.readFile(filePath));
        } catch (err) {
            return {};
        }
    }

    async writeJsonFile(filePath, content) {
        await fs.mkdir(path.dirname(filePath), { recursive: true })
        await fs.writeFile(filePath, JSON.stringify(content, null, 2));
        await fs.chmod(filePath, 0o600); // -rw-------
    }

    _getServiceCredentials(binding, services, options) {
        const { to, 'to-app-services': app, credentials } = options;
        if (!credentials) {
            return
        }
        // toService has format <service-name>[:<key>]
        const toServices = to ? to.split(',') : services.map(s => s.binding.instance);
        const toService = toServices.find(toService => binding.type === 'cf' ?
            toService === binding.instance || toService === binding.instance + ':' + binding.key :
            toService === binding.secret);
        if (!toService) {
            // must never happen
            throw new Error(`Internal error: Service ${binding.instance}:${binding.key} not found`);
        }
        // app based binding always requires service name as key in credentials
        if (!app && toServices.length === 1) {
            return credentials[toService] || credentials;
        }
        return credentials[toService];
    }
}

module.exports = new UserCdsrcJsonStorageProvider();
