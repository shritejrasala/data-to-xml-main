const path = require('path');

const fs = require('fs').promises;

const cds = require('../../../lib/cds');
const { exists, read } = cds.utils;

const { build } = require('../../build');

const hdi = require('./hdiDeployUtil');
const cfUtil = require('../../util/cf');
const gitUtil = require('../../util/git');
const mtaUtil = require('./mtaUtil');

const { bold, info, warn } = require('../../util/term');

const { bind, storeBindings } = require('../../bind');
const { BUILD_TASK_HANA, OUTPUT_MODE, OUTPUT_MODE_FILESYSTEM, OUTPUT_MODE_RESULT } = require('../../build/constants');

const DEBUG = cds.debug('cli');

module.exports = new class HanaDeployer {

  getFromEnv(...varNames) {
    const result = {}
    for (const varName of varNames) {
      if (process.env[varName]) {
        try {
          result[varName] = JSON.parse(process.env[varName]);
        } catch (err) {
          throw new Error(`Error parsing environment variable ${varName}`);
        }
      }
    }
    return result;
  }

  async deploy(options = {}) {
    let { model, serviceName: pServiceName, tunnelAddress, vcapFile, undeployWhitelist, hdiOptions = {}, dry, storeCredentials } = options;

    options.for = options.for || 'hybrid';

    if (model) {
      throw `Specifying a CDS model for HANA deployment is not supported.
'cds deploy --to hana' performs 'cds build --for hana' which in turn uses the configured HANA build task.
Therefore, specifying the CDS model is not required when calling 'cds deploy'.`;
    }

    if (dry) {
      console.log('-- running in dry mode ---');
    }

    if (vcapFile) {
      console.log(`Using VCAP_SERVICES from file ${vcapFile}.`);
    }

    const fromFile = vcapFile && exists(vcapFile) ? await read(vcapFile) : {};
    const fromEnv = this.getFromEnv('VCAP_SERVICES', 'SERVICE_REPLACEMENTS');
    const vcapEnv = { ...fromEnv, ...fromFile };

    const warnings = [];
    if (pServiceName && vcapEnv.VCAP_SERVICES?.hana?.[0].name !== pServiceName) {
      if (vcapFile) {
        warnings.push(`The specified service name '${pServiceName}' was used; the information coming from --vcap-service file was ignored.`);
      } else if (Object.keys(fromEnv).length > 0) {
        warnings.push(`The specified service name '${pServiceName}' was used; the information coming from environment variable VCAP_SERVICES was ignored.`);
      }
    }

    const buildResults = await this._build();

    if (process.env.TARGET_CONTAINER) {
      vcapEnv.TARGET_CONTAINER = process.env.TARGET_CONTAINER;
    }

    for (const { task, result } of buildResults) {
      if (dry) {
        const sortedResult = Array.from(result.hana).sort();
        for (const file of sortedResult) {
          const srcPath = path.join(result.dest, file);
          console.log(`-- ${path.relative(cds.root, srcPath)}`);
          console.log(await read(srcPath));
          console.log();
        }
      } else {
        const dest = task.dest;

        let serviceName = pServiceName;
        let serviceKeyName;
        if (!serviceName && cds.env.requires.db?.binding?.instance) {
          serviceName = cds.env.requires.db.binding.instance;
          serviceKeyName = cds.env.requires.db.binding.key;
        }

        if (undeployWhitelist) {
          console.log('Writing undeploy.json');
          await fs.write(path.join(dest, 'undeploy.json'), JSON.stringify(undeployWhitelist, null, 2));
        }

        const hasVCAPEnv = Object.keys(vcapEnv).length > 0;
        if (!serviceName && hasVCAPEnv) {
          await fs.mkdir(dest, { recursive: true });
        } else {
          const { cfServiceInstanceName, cfServiceInstanceKeyName, serviceKey } =
            await this._getOrCreateCFService(dest, serviceName, serviceKeyName, tunnelAddress);

          serviceName ??= cfServiceInstanceName;
          serviceKeyName ??= cfServiceInstanceKeyName
          if (!vcapEnv.VCAP_SERVICES || serviceName) {
            vcapEnv.VCAP_SERVICES = this._getVCAPServicesEntry(cfServiceInstanceName, serviceKey);
          }

          if (storeCredentials) {
            await this._addInstanceToDefaultEnvJson([dest, cds.root], cfServiceInstanceName, serviceKey);
          }
        }

        console.log(`${bold('Starting deployment to SAP HANA ...')}`);
        DEBUG?.({ dest, vcapEnv, hdiOptions })
        await hdi.deploy(dest, vcapEnv, hdiOptions);

        if (!hasVCAPEnv) {
          const bindOptions = {
            ...options,
            to: `${serviceName}:${serviceKeyName}`,
            for: options.for,
            kind: task.for
          }
          const services = await bind(bindOptions);
          await storeBindings(services, bindOptions);
        }
      }

      if (storeCredentials) {
        await gitUtil.ensureFileIsGitignored('default-env.json', cds.root);
      }

      console.log(`If not already done, use ${info('cds add hana')} to configure the project for SAP HANA.\n`);
    }

    console.log(`Done.`);

    if (warnings.length > 0) {
      console.warn(warn('\nWARNING:'));
      console.warn(warn(warnings.join('\n')));
    }

    return { buildResults };
  }


  async _getOrCreateCFService(currentModelFolder, serviceName, serviceKeyName, tunnelAddress) {
    const modelName = path.basename(currentModelFolder);

    // get from param
    let cfServiceInstanceMta;
    let cfServiceInstanceName;
    if (serviceName) {
      cfServiceInstanceName = serviceName;
    } else {
      const cfServiceDescriptor = await mtaUtil.getHanaDbModuleDescriptor(cds.root, modelName);
      cfServiceInstanceName = cfServiceDescriptor.hdiServiceName;
      cfServiceInstanceMta = cfServiceDescriptor.hdiService
    }

    console.log();
    this._validateServiceInstanceName(cfServiceInstanceName);
    console.log(`Using container ${bold(cfServiceInstanceName)}`);

    const cfConfig = cfServiceInstanceMta?.parameters?.config;
    const serviceInstance = await this.createHanaService(cfServiceInstanceName, cfConfig);

    const cfServiceInstanceKeyName = serviceKeyName ?? `${cfServiceInstanceName}-key`;
    let credentials = await cfUtil.getOrCreateServiceKey(serviceInstance, cfServiceInstanceKeyName, { permissions: 'development' });
    this._validateCredentials(credentials, cfServiceInstanceKeyName);

    if (tunnelAddress) {
      console.log(`Using tunnel address ${bold(tunnelAddress)} (beta feature)`);
      credentials = this._injectTunnelAddress(credentials, tunnelAddress)
    }

    return { cfServiceInstanceName, cfServiceInstanceKeyName, serviceKey: credentials, serviceInstance }
  }


  async createHanaService(instanceName, cfConfig) {
    // hana or hanatrial, error if neither found
    try {
      return await cfUtil.getOrCreateService('hana', 'hdi-shared', instanceName, cfConfig);
    } catch (error) {
      if (error.command && /offering .* not found/i.test(error.command.stderr)) {
        console.log(`Falling back to 'hanatrial'`);
        return await cfUtil.getOrCreateService('hanatrial', 'hdi-shared', instanceName, cfConfig);
      }
      else if (error.command && /no database/i.test(error.command.stderr)) {
        console.log(`No database connected to 'hana' service. Falling back to 'hanatrial'`);
        return await cfUtil.getOrCreateService('hanatrial', 'hdi-shared', instanceName, cfConfig);
      }
      throw error;
    }
  }


  _validateCredentials(credentials, cfServiceInstanceKey) {
    if (!credentials) {
      throw `Could not create service key ${bold(cfServiceInstanceKey)}.`;
    }

    if (credentials['sm_url']) {
      throw `Service key credentials are matching to a Service Manager instance of a multitenant environment. Make sure there is no conflict with ${cfServiceInstanceKey}.`;
    }

    const fields = ['schema', 'user', 'password', 'url'];
    for (const field of fields) {
      if (!credentials[field]) {
        throw `Service key is missing mandatory field '${field}'. Make sure you are ${bold('not')} using a managed service.`;
      }
    }
  }


  async _build() {
    const buildTaskOptions = {
      for: BUILD_TASK_HANA,
      src: cds.env.folders.db,
      [OUTPUT_MODE]: OUTPUT_MODE_FILESYSTEM | OUTPUT_MODE_RESULT
    }

    console.log(`Running build`);
    return build(buildTaskOptions);
  }

  async _addInstanceToDefaultEnvJson(currentFolders, serviceInstanceName, serviceKey) {
    for (const currentFolder of currentFolders) {
      const defaultEnvJsonPath = path.join(currentFolder, 'default-env.json');
      const defaultEnvJson = exists(defaultEnvJsonPath) ? await read(defaultEnvJsonPath) : {};

      defaultEnvJson.VCAP_SERVICES ??= {};
      for (const [serviceKey, services] of Object.entries(defaultEnvJson.VCAP_SERVICES)) {
        defaultEnvJson.VCAP_SERVICES[serviceKey] = services.filter(service => service.name !== serviceInstanceName);
      }

      const hanaEntry = this._getVCAPServicesEntry(serviceInstanceName, serviceKey)
      Object.assign(defaultEnvJson.VCAP_SERVICES, hanaEntry);

      console.log(`Writing ${defaultEnvJsonPath}`);
      await fs.mkdir(path.dirname(defaultEnvJsonPath), { recursive: true })
      await fs.writeFile(defaultEnvJsonPath, JSON.stringify(defaultEnvJson, null, 2));
    }
  }


  _getVCAPServicesEntry(serviceInstanceName, serviceKey) {
    return {
      hana: [
        {
          name: serviceInstanceName,
          tags: ['hana'],
          credentials: serviceKey
        }
      ]
    };
  }


  _validateServiceInstanceName(serviceInstanceName) {
    // valid service name chars: alpha-numeric, hyphens, and underscores
    if (/[^\w-_]+/g.exec(serviceInstanceName)) {
      throw `Service name ${serviceInstanceName} must only contain alpha-numeric, hyphens, and underscores.`;
    }
  }


  _injectTunnelAddress(credentials, tunnelAddress) {
    if (!/\w+:\d+/.test(tunnelAddress)) {
      throw `Invalid tunnel address '${tunnelAddress}' - must be in form 'host:port'`;
    }
    const [tunnelHost, tunnelPort] = tunnelAddress.split(':')
    const { host, port } = credentials
    credentials.host = tunnelHost
    credentials.port = tunnelPort
    credentials.url = credentials.url.replace(`${host}:${port}`, tunnelAddress)
    credentials.hostname_in_certificate = host  // make cert. verification happy, see xs2/hdideploy.js#527
    credentials.url = credentials.url + (credentials.url.includes('?') ? '&' : '?') + 'hostNameInCertificate=' + host
    return credentials
  }
}
