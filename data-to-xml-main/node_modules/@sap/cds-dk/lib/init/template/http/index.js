const https = require('node:https')
const axios = require('axios')
const asJson = require("../data/as-json")
const cds = require('../../../cds')
const cf = require("../../../util/cf")
const { write, exists } = cds.utils
const { filterStringAsRegex } = require("../data/index")

module.exports = class HttpTemplate extends require('../../plugin') {

  #nodeHost = "http://localhost:4004"
  #javaHost = "http://localhost:8080"
  #defaultOutputDir = "test/http"
  #defaultAuth = `Authorization: Basic alice:`

  static help() {
    return 'add .http files for modeled services'
  }

  options() {
    return {
      'filter': {
        type: 'string',
        short: 'f',
        help: `Filter for services or entities or actions matching the given pattern. If it contains meta
        characters like '^' or '*', it is treated as a regular expression,
        otherwise as an include pattern, i.e /.*pattern.*/i`
      },
      'for-app': {
        type: 'string',
        short: 'a',
        help: 'Specify the name of the app to generate requests for. If not specified, localhost and default auth will be used.'
      },
      'out': {
        type: 'string',
        short: 'o',
        help: 'The output directory. By default, an `http` dir will be created in one of the following: test/tests/__tests__, whichever already exists. If none exists, an `http` dir will be created at the root level.'
      },
      'dry': {
        type: 'boolean',
        help: 'Print the generated requests to the console instead of writing them to a file.'
      }
    }
  }

  async run() {
    const csn = await cds.load(cds.env.roots).then(cds.minify)
    cds.linked(csn)

    const serviceInfo = cds.compile.to.serviceinfo(csn)
    let [hostname, auth] = await this.#getHostnameAndAuth(serviceInfo)
    let services = this.#collectServiceInfo(csn, serviceInfo)
    if (!services)  return

    const payload = await this.#generatePayload(csn, services)
    this.#generateRequests(services, hostname, auth, payload)
  }

  async #getHostnameAndAuth(serviceInfo) {
    if (!cds.cli.options['for-app']) {
      if (serviceInfo[0].runtime === 'Java') {
        return [this.#javaHost, null]
      } else {
        return [this.#nodeHost, this.#defaultAuth]
      }
    }

    const app = cds.cli.options['for-app']
    // Later: differentiate between CF and Kyma
    const env = await cf.getEnv(app)
    if (!cds.cli.options.dry)   console.error('Fetching credentials from Cloud Foundry app \'' + app + '\'...')
    const hostname = `https://${env.application_env_json.VCAP_APPLICATION.application_uris[0]}`
    const xsuaaCredentials = env.system_env_json.VCAP_SERVICES?.xsuaa[0]?.credentials ?? {}
    const { url, clientid, clientsecret, certurl, certificate, key } = xsuaaCredentials
    if (!url) throw new Error('No XSUAA service found in the environment of ' + app)

    const auth = certificate ? { maxRedirects: 0, httpsAgent: new https.Agent({ cert: certificate, key }) }
                             : { auth: { username: clientid, password: clientsecret } }
    const authUrl = `${certurl ?? url}/oauth/token`
    const data = `grant_type=client_credentials&client_id=${encodeURI(clientid)}`
    const config = { method: 'POST', timeout: 5000, data, ...auth }
    const { access_token } = (await axios(authUrl, config)).data
    const approuterAuth = `x-approuter-authorization: bearer ${access_token}`
    return [hostname, approuterAuth]
  }

  #collectServiceInfo(csn, serviceInfo) {
    const services = new Map()

    const filter = cds.cli.options['filter']

    csn.services.map((s) => {
      const sInfo = serviceInfo.find(info => info.name === s.name)
      const urlPaths = sInfo?.endpoints?.map(e => e.path) ?? [sInfo?.urlPath]
      if (!urlPaths) return
      let entities = []
      let actions = []

      for (const c of csn.childrenOf(s.name)) {
        if (c.name.match(filterStringAsRegex(filter))) {
          if (c.name.includes('.texts')) continue
          c.kind === 'entity' ? entities.push(this.#addEntityInfo(c)) : c.kind === 'action' ? actions.push(c) : null
        }
      }
      if (entities.length === 0 && actions.length === 0) return
      services.set(s.name, { entities, urlPaths, actions })
    })

    if (services.size === 0) {
      console.error(`No services found for filter ${filter}`)
      process.exitCode = 1
      return
    }

    return services
  }

  #addEntityInfo(e) {
    return {
      name: e.name,
      readOnly: (e["@readonly"] || e["@cds.autoexpose"] || e['@odata.singleton']) ?? false,
      isDraft: e['@odata.draft.enabled'] ?? false,
      keys: e.keys
    }
  }

  async #generatePayload(csn, services) {
    const payload = {}
    for (const [, service] of services) {
      for (const e of service.entities) {
        payload[e.name] = []
      }
    }
    // csn.all('entity').reduce((all, e) => { all[e.name] = []; return all }, {})
    await asJson(payload, csn, 1)
    for (const p in payload) {
      delete payload[p][0].texts
      delete payload[p][0].localized
    }
    return payload
  }

  #generateRequests(services, hostname, auth, payload) {
    let varsDefined = false  // when writing requests for multiple services to stdout, define vars only once
    for (const [serviceName, service] of services) {
      let requests = []
      if (!cds.cli.options.dry || !varsDefined) {
        requests.push(auth ? `@server = ${hostname}\n@auth = ${auth}\n` : `@server = ${hostname}\n`)
      }
      varsDefined = true
      const headers = auth ? `Content-Type: application/json\n{{auth}}` : `Content-Type: application/json`
      const headerAuth = auth ? '{{auth}}' : ''

      service.urlPaths.forEach((urlPath) => {
        if (service.urlPaths.length > 1) {
          requests.push(`\n# Service endpoint: ${urlPath}`)
        }

        service.entities.forEach((e) => {
          const entityNameSimple = e.name.slice(serviceName.length + 1)
          const nameSlug = slug(entityNameSimple)
          const url = `{{server}}/${urlPath}${entityNameSimple}`
          const requestTitle = `\n### ${entityNameSimple}`
          requests.push(`${requestTitle}\n# @name ${nameSlug}_GET\nGET ${url}\n${headerAuth}\n`)
          if (e.readOnly) return

          const entityData = payload[`${e.name}`] ? payload[`${e.name}`][0] : null
          if (!entityData) return

          if (e.isDraft) {
            const key = Object.keys(e.keys)[0] // draft keys are always single
            delete entityData[key] // draft keys should always by auto generated (either UUID or through custom logic), so remove them from the payload
            const postBody = JSON.stringify(entityData, null, 2)
            generateDraftRequests(requests, requestTitle, url, headers, headerAuth, postBody, key)
          }
          else {
            const postBody = JSON.stringify(entityData, null, 2)
            let id
            const compositeKey = Object.keys(e.keys).length > 1
            if (compositeKey) {
              id = [...e.keys].map(k => k.type === 'cds.String' ? `${k.name}='${entityData[k.name]}'` : `${k.name}=${entityData[k.name]}`).join(',')
            } else {
              id = entityData[Object.keys(e.keys)[0]]
            }
            compositeKey ? id = `(${id})` : id = `/${id}`
            requests.push(`${requestTitle}\n# @name ${nameSlug}_POST\nPOST ${url}\n${headers}\n\n${postBody}\n`)
            requests.push(`${requestTitle}\n# @name ${nameSlug}_PATCH\nPATCH ${url}${id}\n${headers}\n\n${postBody}\n`)
            requests.push(`${requestTitle}\n# @name ${nameSlug}_DELETE\nDELETE ${url}${id}\n${headers}\n`)
          }
        })

        service.actions.forEach((a) => {
          const simpleNameAction = a.name.slice(serviceName.length + 1)
          const url = `{{server}}/${urlPath}${simpleNameAction}`

          let actionPayload = {}
          if (a.params) {
            for (const [key, value] of Object.entries(a.params)) {
              actionPayload[key] = value.type === 'cds.Integer' ? 1
                : value.type === 'string' ? 'sample string'
                  // TODO reference an object that has been generated
                  : typeof value.type === 'object' && value.type.ref ? payload[value.type.ref[0]][0][value.type.ref[1]]
                    : null
            }
          }
          requests.push(`\n### ${simpleNameAction}\n# @name ${simpleNameAction}_POST\nPOST ${url}\n${headers}\n\n${JSON.stringify(actionPayload, null, 2)}\n`)
        })

      })
      this.#write(requests, serviceName)
    }

    function generateDraftRequests(requests, title, url, headers, headerAuth, postBody, key) {
      const nameDraftsCreate = slug(title+'_Draft_POST')
      requests.push(`${title} Drafts GET\n# @name ${slug(title+'_Drafts_GET')}\nGET ${url}?$filter=(IsActiveEntity eq false)\n${headerAuth}\n`) // unencoded URL for better readability (client can handle this)
      requests.push(`${title} Draft POST\n# @name ${nameDraftsCreate}\nPOST ${url}\n${headers}\n\n${postBody}\n`)
      requests.push(`\n### Result from POST request above\n@draftID = {{${nameDraftsCreate}.response.body.$.${key}}}\n`)
      requests.push(`${title} Draft PATCH\n# @name ${slug(title+'_Draft_Patch')}\nPATCH ${url}(${key}={{draftID}},IsActiveEntity=false)\n${headers}\n\n${postBody}\n`)
      requests.push(`${title} Draft Prepare\n# @name ${slug(title+'_Draft_Prepare')}\nPOST ${url}(${key}={{draftID}},IsActiveEntity=false)/AdminService.draftPrepare\n${headers}\n\n{}\n`)
      requests.push(`${title} Draft Activate\n# @name ${slug(title+'_Draft_Activate')}\nPOST ${url}(${key}={{draftID}},IsActiveEntity=false)/AdminService.draftActivate\n${headers}\n\n{}\n`)
    }

    function slug(str) {
      return str.trim().replace(/[#\\. ]/g, '')
    }
  }

  #write(requests, serviceName) {
    const http = requests.join('\n')
    if (cds.cli.options.dry) {
      console.log(http)
    } else {
      const term = require('../../../util/term')
      const outputPath = this.#determineOutputPath(serviceName)
      if (exists(outputPath)) {
        if (cds.cli.options.force) {
          console.log(term.dim(`  Overwriting ${outputPath}`))
        } else {
          console.log(term.dim(`  Skipping ${outputPath}`))
          return
        }
      } else {
        console.log(term.dim(`  Creating ${outputPath}`))
      }
      write(http).to(outputPath)
    }
  }

  #determineOutputPath(serviceName) {
    let outputDir
    const { out } = cds.cli.options
    if (out) {
      outputDir = out.endsWith('/') ? out.slice(0, -1) : out
    } else if (exists('test') || exists('tests') || exists('__tests__')) {
      outputDir = exists('test') ? 'test/http' : (exists('tests') ? 'tests/http' : '__tests__/http')
    } else {
      outputDir = this.#defaultOutputDir
    }
    return `${outputDir}/${serviceName}.http`
  }
}
