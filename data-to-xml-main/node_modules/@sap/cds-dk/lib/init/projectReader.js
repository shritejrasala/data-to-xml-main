const cds = require('../cds')
const { join, resolve, basename } = require('path')
const { fs, exists, isdir, path } = cds.utils
const { parseXml } = require('./xml')
const { REGEX_JAVA_VERSION, JAVA_LTS_VERSIONS } = require('./constants')
const TRACE = cds.debug('trace')

module.exports = new class ProjectReader {

    constructor() {
        this.readProject = this.readProject.bind(this)
    }

    #setPackageInfo() {
        // 1. Use project name and static default values
        this.appVersion = cds.cli.options?.add?.has('java') ? '1.0.0-SNAPSHOT' : '1.0.0'
        this.appName = this.appId = basename(cds.root)
        this.appDescription = 'A simple CAP project.'

        const isJava = exists('pom.xml') || cds.cli.options?.add?.has('java')
        if (isJava) {
            let artifactId, description, version, properties
            try {
                ({ artifactId, description, version, properties } = parseXml(resolve(cds.root, 'pom.xml')) ?? {})
            } catch (e) {
                if (e.code !== 'ENOENT') throw e
            }
            const v = version?.[0] === '${revision}' ? properties?.[0]?.revision[0] : version?.[0] ?? '1.0.0-SNAPSHOT'
            if (v && REGEX_JAVA_VERSION.test(v)) this.appVersion = v
            this.jdkVersion = properties?.[0]?.['jdk.version']?.[0]?._text?.[0] ?? JAVA_LTS_VERSIONS[JAVA_LTS_VERSIONS.length - 1]
            if (artifactId?.[0])  this.appName = this.appId = artifactId?.[0]?.split(/-parent/)[0]
            if (description?.[0]) this.appDescription = description[0]
        }
        else if (exists('package.json')) {
            const { name, version, description } = JSON.parse(fs.readFileSync(join(cds.root, 'package.json')))
            this.appVersion = version ?? this.appVersion
            const segments = (name ?? this.appName).trim().replace(/@/g, '').split('/').map(encodeURIComponent)
            this.appName = segments[segments.length - 1]
            this.appId = segments.join('.')
            this.appDescription = description ?? this.appDescription
        }
    }

    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    env4(profile = 'production') {
        const cdsEnv = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            return cds.env.for('cds')
        } finally {
            cdsEnv ? process.env.CDS_ENV = cdsEnv : delete process.env.CDS_ENV
        }
    }

    /**
     * @typedef {Object} ProjectConfig
     * @property {string} appVersion The version of the application.
     * @property {string} appName The name of the application.
     * @property {string} appId The ID of the application.
     * @property {string} appDescription The description of the application.
     * @property {string} language The programming language of the project.
     * @property {string} srvPath The path to the server module.
     * @property {string} archiveName The name of the archive.
     * @property {Object} db Database configuration.
     * @property {string} configFile The name of the configuration file. This is typically the `package.json` for Node.js and `.cdsrc.json` for Java.
     * @property {string} appPath The path to the app folder.
     * @property {string} approuterPath The path to the approuter folder.
     * @property {boolean} hasUIEmbedded Indicates if the project uses an embedded UI.
     * @property {boolean} hasUIModule Indicates if the project is using a modular UI.
     * @property {boolean} hasUI Indicates if the project has a UI.
     * @property {boolean} hasUI5 Indicates if the project is a UI5 project.
     * @property {boolean} isUI5 Indicates if the project is a UI5 project.
     * @property {boolean} isJava Indicates if the project is using Java.
     * @property {boolean} isNodejs Indicates if the project is using Node.js.
     * @property {boolean} hasHelmUnifiedRuntime Indicates if the project uses Unified Runtime Helm deployment.
     * @property {boolean} hasHelm Indicates if the project uses CAP Helm deployment.
     * @property {boolean} hasMta Indicates if the project uses MTA deployment.
     * @property {boolean} hasConnectivity Indicates if the project uses connectivity.
     * @property {boolean} hasMultitenancy Indicates if the project is multitenant.
     * @property {boolean} hasToggles Indicates if the project uses feature toggles.
     * @property {boolean} hasExtensibility Indicates if the project is extensible.
     * @property {boolean} hasXsuaa Indicates if the project uses XSUAA.
     * @property {boolean} hasHana Indicates if the project uses HANA.
     * @property {boolean} hasPostgres Indicates if the project uses PostgreSQL.
     * @property {boolean} hasEnterpriseMessaging Indicates if the project uses SAP BTP Event Mesh.
     * @property {boolean} hasAttachments Indicates if the project uses SAP BTP Object Store Service.
     * @property {boolean} hasApprouter Indicates if the project uses the SAP Application Router.
     * @property {boolean} hasHtml5Repo Indicates if the project uses the SAP BTP HTML5 Application Repository.
     * @property {boolean} hasPortal Indicates if the project uses the SAP Cloud Portal service.
     * @property {boolean} hasWorkzone Indicates if the project uses the SAP Build Work Zone service.
     * @property {boolean} hasDestination Indicates if the project uses the SAP BTP Destination service.
     * @property {boolean} hasMTXRoute Indicates if the approuter should have a multitenant route.
     * @property {boolean} hasMTXRouteJava Indicates if the approuter should have a multitenant subscription route (java).
     * @property {boolean} hasMalwareScanner Indicates if the project uses the SAP Malware Scanning service.
     * @property {boolean} hasDynatrace Indicates if the project uses Dynatrace.
     *
     */

    /**
     * Reads the project configuration and constructs a project object.
     * This function dynamically resolves project properties and returns an object with these properties.
     *
     * @returns {ProjectConfig} An object representing the project configuration.
     */
    readProject() {
        if (!this.appName) this.#setPackageInfo()
        const env = this.env4('production')
        const { appVersion, appName, appId, appDescription, jdkVersion } = this
        TRACE?.({ env })

        const _inProd = plugin => require(`./template/${plugin}`).hasInProduction(env)
        const _ui5 = () => exists('package.json') && !!JSON.parse(fs.readFileSync(path.resolve(cds.root, 'package.json'))).sapux
        const _uiEmbedded = () => exists(join(env.folders.app, 'xs-app.json'))
        const _uiModule = () => !_uiEmbedded() && isdir(env.folders.app) && fs.readdirSync(resolve(cds.root, env.folders.app)).length > 0
        const _isJava = () => exists('pom.xml') || cds.cli.options?.add?.has('java')
        const isApp = name => name !== 'appconfig' && !name.startsWith('_') && name !== 'router' && name !== 'portal'
        const reserved = {
            has: x => _inProd(x),
            shortcut: () => true,
            profile: () => cds.cli.options?.for,
            language: () => exists('pom.xml') ? 'java' : 'nodejs',
            isJava: () => _isJava(),
            isNodejs: () => !_isJava(),
            srvPath: () => join(env.build.target, env.folders.srv.replace(/\/$/, '')).replace(/\\/g, '/'),
            archiveName: () => {
                const pomXmlPath = resolve(cds.root, env.folders.srv, 'pom.xml')
                const pom = exists(pomXmlPath) ? parseXml(pomXmlPath) : {}
                const { artifactId = [basename(cds.root)], packaging = ['jar'] } = pom
                return artifactId[0] + '-exec.' + packaging[0]
            },
            db: () => {
                const folder = env.folders.db
                const name = folder.replace(/\/$/, '')
                const path = join(env.build.target, name).replace(/\\/g, '/')
                return { folder, name, path }
            },
            configFile: () => exists('pom.xml') ? '.cdsrc.json' : 'package.json',
            apps: () => {
                const apps = fs.readdirSync(path.resolve(cds.root, cds.env.folders.app)).filter(e =>
                    isdir(path.join(cds.root, cds.env.folders.app, e)) && isApp(e)
                )
                return apps.map((app, i) => {
                    const manifestPath = path.resolve(cds.root, cds.env.folders.app, app, 'webapp/manifest.json')
                    const manifest = exists(manifestPath) ? JSON.parse(fs.readFileSync(manifestPath, 'utf-8')) : {}
                    const inbounds = manifest?.['sap.app']?.crossNavigation?.inbounds
                    const [firstInbound] = Object.values(inbounds ?? { intent: { semanticObject: 'Books', action: 'display' }})
                    const vizId = firstInbound.semanticObject + '-' + firstInbound.action
                    return { app, strippedApp: app.replace(/-/g, ''), vizId, isNotLast: i < apps.length - 1, manifestAppId: manifest?.['sap.app']?.id ?? app}
                })
            },
            appUIPaths: () => (fs.readdirSync(path.resolve(cds.root, cds.env.folders.app))).filter(e =>
                isdir(join(cds.root, cds.env.folders.app, e)) && isApp(e)
            ),
            appPath: () => env.folders.app,
            appVersion: () => appVersion,
            jdkVersion: () => jdkVersion,
            approuterPath: () => _uiEmbedded() ? join(env.folders.app) : join(env.folders.app, 'router'),
            appName: () => appName,
            cleanedAppName: () => appName.replaceAll('_', '-'),
            strippedAppName: () => appName.replace(/-/g, ''),
            appId: () => appId,
            appDescription: () => appDescription,
            hasUIEmbedded: _uiEmbedded,
            hasUIModule: _uiModule,
            hasUI: () => _uiEmbedded() || _uiModule(),
            isUI5: _ui5,
            hasUI5: _ui5,
            hasMTXRoute: () => _inProd('extensibility') || (_inProd('multitenancy') && !_isJava()),
            hasMTXRouteJava: () => (_inProd('helm-unified-runtime') || _inProd('helm')) && _isJava() && _inProd('multitenancy'),
        }

        // Automatically creates availability checks for `cds add` commands.
        // Maps to the `hasInProduction` implemented in the command.
        // E.g. `cds add hana` can be checked using `hasHana` or `isHana`
        const project = (() => {
            const defined = {}
            const _get = property => { const p = property
                if (p in reserved) return reserved[p]()
                for (const prefix of ['has', 'is']) if (p.startsWith(prefix) && p.length > prefix.length) {
                    return _inProd(p.slice(prefix.length).replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase())
                }
            }
            return new Proxy({}, {
                get(_, p) { return _get(p) ?? defined[p] },
                set(_, p, value) { defined[p] = value; return true },
                has(_, p) { return _get(p) ?? p in defined }
            })
        })()

        return project
    }
}
