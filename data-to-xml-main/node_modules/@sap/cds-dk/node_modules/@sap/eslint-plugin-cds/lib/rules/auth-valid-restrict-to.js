'use strict'

const { isEmptyString, isStringInArray, findFuzzy, isEmptyObject } = require('../utils/rules')

const VALID_PSEUDO_ROLES = ['authenticated-user', 'system-user', 'any']

module.exports = {
  meta: {
    schema: [{/* to avoid deprecation warning for ESLint 9 */}],
    docs: {
      description: '`@restrict.to` must have valid values.',
      category: 'Model Validation',
      recommended: true,
      url: 'https://cap.cloud.sap/docs/tools/cds-lint/meta/auth-valid-restrict-to',
    },
    messages: {
      invalidItem: "Invalid item '{{invalid}}'. Did you mean '{{candidates}}'?",
      missingRole: "Missing role on '{{name}}' for `@restrict.to`.",
      missingRoles: "Missing roles on '{{name}}' for `@restrict.to`."
    },
    type: 'problem',
    model: 'inferred'
  },
  create (context) {
    return {
      entity: checkRestrictTo
    }

    function checkRestrictTo (e) {
      const USER_ROLES = []
      const model = context.getModel()
      if (!model)
        return

      model.foreach('entity', e => {
        if (e['@restrict']) {
          e['@restrict'].forEach(p => {
            if (p.to) {
              switch (typeof p.to) {
              case 'string':
                if (p.to !== p.to.toLowerCase() && !USER_ROLES.includes(p.to)) {
                  USER_ROLES.push(p.to)
                }
                break
              case 'object':
                for (const r in p.to) {
                  if (r !== r.toLowerCase() && !USER_ROLES.includes(r)) {
                    USER_ROLES.push(r)
                  }
                }
              }
            }
          })
        }
      })
      const ROLES = USER_ROLES.concat(VALID_PSEUDO_ROLES)

      if (e['@restrict']) {
        const node = context.getNode(e)
        const file = e.$location.file

        // TODO: For hierachies, check whether service restriction exists
        // const { prefix } = splitDefName(e)
        // const prefixSplit = prefix.split('.')
        // const serviceName = prefixSplit[prefixSplit.length - 1]
        // const services = model.services
        // let grantAllTo;
        // Object.values(services).map((s) => {
        //   if (s.name === serviceName && s['@requires']) {
        //     grantAllTo = s['@requires'];
        //   }
        // })

        for (const entry of e['@restrict']) {
          if (Object.keys(entry).includes('to')) {
            const toValue = entry.to

            switch (typeof toValue) {
            case 'string': {
              if (isEmptyString(toValue)) {
                context.report({
                  messageId: 'missingRole',
                  data: { name: e.name },
                  node,
                  file,
                })
              } else {
                const isPseudoRole = entry.to && entry.to === entry.to.toLowerCase()
                if (!isStringInArray(toValue, ROLES, isPseudoRole)) {
                  const candidates = findFuzzy(toValue, ROLES.sort())
                  context.report({
                    messageId: 'invalidItem',
                    data: { invalid: toValue, candidates },
                    node,
                    file,
                  })
                }
              }
              break
            }

            case 'object':
              if (isEmptyObject(toValue)) {
                context.report({
                  messageId: 'missingRoles',
                  data: { name: e.name },
                  node,
                  file,
                })
              } else {
                // If values contain 'any', 'any' only is enough
                if (toValue.length > 1 && toValue.includes('any')) {
                  context.report({
                    messageId: 'invalidItem',
                    data: { invalid: `[${toValue}]`, candidates: ['["any"]'] },
                    node,
                    file,
                  })
                }
                toValue.forEach(value => {
                  if (!ROLES.includes(value)) {
                    const candidates = findFuzzy(value, ROLES.sort(), undefined, false, 2)
                    if (candidates.length > 0) {
                      context.report({
                        messageId: 'invalidItem',
                        data: { invalid: value, candidates },
                        node,
                        file,
                      })
                    }
                  }
                })
              }
              break
            }
          }
        }
      }
    }
  }
}
