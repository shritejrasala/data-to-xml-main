'use strict'

/*
 * Wrapper for ESLint's Rule creator:
 * https://eslint.org/docs/developer-guide/working-with-rules
 * - Must follow the ESLint prescribed convention for all rule exports
 * - ESLint uses 'create' function to traverse its AST nodes
 * - Since we do not work with an AST for cds models, a dummy 'Programm' node is used as an entry point
 * - More eslint-like API
 * - More convenience for error reports
 * @param {CDSRuleSpec} spec
 * @returns {RuleModule}
 */

const { SourceCode } = require('eslint')
const fs = require('fs')
const path = require('path')
const cds = require('@sap/cds')

const Cache = require('./Cache')
const constants = require('../constants')
const isConfiguredFileType = require('./isConfiguredFileType')
const getProjectRootPath = require('./getProjectRootPath')
const { CdsLintAssertionError } = require('./LintError')

const LOG = cds.debug('lint:plugin')
let filePrev = ''

const REGEX_COMMENT_START = '(/\\*|(.+)?//)(\\s?)+eslint-'
const REGEX_COMMENTS = `${REGEX_COMMENT_START}(enable|disable)(-next)?(-line)?(.+)?`

module.exports = function createRule(spec) {
  let { meta, create } = spec
  meta = setMetaDefaults(meta)

  return {
    meta,
    create: context => {
      // do a fast check to exclude most cases, i.e. irrelevant files
      const isRelevant =
        context.getSourceCode().lines[0] === '' || // env. rules
        isConfiguredFileType(context.getFilename(), 'FILES') // file rules
      if (!isRelevant) {
        return {}
      }

      return {
        Program: node => {
          const file = context.getFilename()
          if (file !== filePrev) {
            LOG && LOG(`File: ${context.getFilename()}`)
          }
          const cdscontext = extendContext(node, context, meta)
          Cache.set('context', cdscontext)
          const { isTest, isValidFile, doEnvironmentChecks, doRootModelChecks, showInEditor } = checkEntryCriteria(meta, cdscontext)
          switch (meta.model) {
          case 'none':
            if (doEnvironmentChecks) {
              if (isTest || !Cache.has(`rule:${cdscontext.id}`)) {
                LOG && LOG(`  Model: "${meta.model}" Rule: ${context.id}`)
                Cache.set(`rule:${cdscontext.id}:${Cache.get('rootpath')}`, 'done')
                createReport(node, cdscontext, meta, create)
              }
            }
            break

          case 'inferred':
            if (isValidFile && doRootModelChecks) {
              if (showInEditor) {
                Cache.remove(`model:${Cache.get('rootpath')}`)
                Cache.remove(`rule:${cdscontext.id}:${Cache.get('rootpath')}`)
                Cache.remove(`report:${context.getFilename()}:${context.id}`)
              }
              if (isTest || showInEditor || !Cache.has(`rule:${cdscontext.id}:${Cache.get('rootpath')}`)) {
                LOG && LOG(`  Model: "${meta.model}" Rule: ${context.id}`)
                if (!showInEditor) {
                  Cache.set(`rule:${cdscontext.id}:${Cache.get('rootpath')}`, 'done')
                }
                createReport(node, cdscontext, meta, create)
              } else {
                if (Cache.has(`report:${context.getFilename()}:${context.id}`)) {
                  const reports = Cache.get(`report:${context.getFilename()}:${context.id}`)
                  for (const r of Array.from(reports)) {
                    context.report(JSON.parse(r))
                  }
                  Cache.remove(`report:${context.getFilename()}:${context.id}`)
                  Cache.set(`rule:${cdscontext.id}:${Cache.get('rootpath')}`, 'done')
                }
              }
            }
            break

          default:
            if (isValidFile) {
              LOG && LOG(`  Model: "${meta.model}" Rule: ${context.id}`)
              createReport(node, cdscontext, meta, create)
            }
            break
          }
          filePrev = file
        }
      }
    }
  }
}

function isRunningWithCDSLint () {
  return process.argv[0].endsWith('node') && process.argv[1].endsWith('cds') && process.argv[2] === 'lint'
}

function isRunningWithESLint () {
  return process.argv[0].endsWith('node') && process.argv[1].endsWith('eslint')
}

function checkEntryCriteria (meta, cdscontext) {
  const isTest = Cache.has('test')
  const showInEditor = cdscontext.options.includes('show')
  const hasProjectRoots = Cache.has(`roots:${Cache.get('rootpath')}`)
  const isValidFile = isConfiguredFileType(cdscontext.getFilename(), 'FILES')
  const doRootModelChecks = isTest || (hasProjectRoots && (isRunningWithCDSLint() || isRunningWithESLint()) || showInEditor)
  // Lint all env rules independent of any parsed file (i.e. 'cds lint' uses the lintText "" API)
  const doEnvironmentChecks =
    isTest || (isRunningWithCDSLint() && cdscontext.getFilename() === '<text>')
  return { isTest, isValidFile, doRootModelChecks, doEnvironmentChecks, showInEditor }
}

function setMetaDefaults (meta) {
  meta ??= {}
  meta.severity ??= constants.DEFAULT_RULE_SEVERITY
  meta.docs ??= {}
  meta.docs.category ??= constants.DEFAULT_RULE_CATEGORY
  meta.model ??= 'parsed'
  return meta
}

/**
 * Get report descriptors from created rules. These can take various forms,
 * from minimal return, up to fully defined ESLint report descriptors values,
 * with or without visitor keys:
 * - String is interpreted as the 'message' property
 * - Object with known CDS Visitor keys and ESLint report descriptor values
 * - Object with ESLint report descriptor keys/ values
 *
 * @param {object} node
 * @param {CDSRuleContext} cdsContext
 * @param {object} meta
 * @param {Function} create
 * @returns
 */
function createReport (node, cdsContext, meta, create) {
  const handlers = create(cdsContext)
  /**
   * TODO: Can these be rewritten to have a visitor? Note, that so far,
   * rules without a visitor cannot use eslint disable comments
   * A rule have no visitors and just return a single check:
   *  - Model Validation rules which have no well-defined CSN entry point
   *  - Environment rules
   */
  switch (typeof handlers) {
  case 'function':
    handlers()
    break

  case 'object': {
    if (meta.model !== 'none') {
      const model = cdsContext.getModel()

      if (model) {
        model.forall(d => {
          d = (meta.model === 'inferred') ? sanitizeFileLocation(d) : d
          const isValidLocation = (meta.model === 'parsed' && d.$location) ||
              (meta.model === 'inferred' && d.$location?.file)
          Object.entries(handlers)
            .filter(([type, ]) => d.is(type) && isValidLocation)
            .forEach(([, handler]) => {
              handler(d)
            })
        })
      }
    }
    break
  }
  }
}

function sanitizeFileLocation (d) {
  let parent = d
  while (!parent.$location && parent.parent && !parent.parent.definitions) parent = d.parent
  if (parent.$location) d.$location = parent.$location
  return d
}

/**
 * @param node
 * @param {CDSRuleContext} context
 * @param meta
 */
function extendContext (node, context, meta) {
  if (!Cache.has('test')) {
    const filePath = context.getFilename()
    const rootPath = filePath && fs.existsSync(filePath) ? getProjectRootPath(filePath) : ''
    if (rootPath) {
      Cache.set('rootpath', rootPath)
    }
  }

  const descriptors = Object.getOwnPropertyDescriptors(context)
  descriptors.report = {
    value: reportWrapper,
    writable: false,
    enumerable: true,
    configurable: false
  }

  const cdscontext = Object.create(Object.getPrototypeOf(context), descriptors)
  const { parserServices } = context.sourceCode || context
  cdscontext.getModel =
    meta.model === 'inferred' ? parserServices.getInferredCsn : parserServices.getParsedCsn
  cdscontext.getEnvironment = () => {
    const options = context.options
    return options && options[0] && options[0].environment ? options[0].environment : undefined
  }
  cdscontext.getLocation = parserServices.getLocation
  cdscontext.getNode = Object.keys(parserServices).length > 0 ? parserServices.getNode : () => node
  cdscontext.getRootPath = () => Cache.get('rootpath')
  return cdscontext

  function reportWrapper(r) {
    const line = r.loc ? r.loc.start.line : r.node.loc.start.line
    if (!isRuleDisabled(line, context)) {
      if (meta.model === 'inferred') {
        if (!r.file) {
          throw new CdsLintAssertionError(`Rule ${context.id} must return a "file" property in the rule report!`)
        }
        const file = Cache.get('rootpath') ? resolveFilePath(r.file) : r.file
        if (cdscontext.getFilename() === file) {
          delete r.file
          context.report(r)
        }
        if (r.file) {
          cacheReport(r, file, context, meta)
        }
      } else {
        context.report(r)
      }
    }
  }
}


/**
 * @param {number} line
 * @param {CDSRuleContext} cdsContext
 */
function isRuleDisabled (line, cdsContext) {
  let isDisabled = false
  if (cdsContext) {
    const sourcecode = cdsContext.getSourceCode()
    const rulesDisabled = getDisabled(sourcecode.getText(), sourcecode, line)
    const id = cdsContext.id
    isDisabled = line && id in rulesDisabled && rulesDisabled[id] === 'off'
  }
  return isDisabled
}

/**
 * @param r
 * @param {string} filepath
 * @param {CDSRuleContext} context
 * @param meta
 */
function cacheReport (r, filepath, context, meta) {
  delete r.file
  if (r.node && r.node.range) {
    r.node.range = []
  }
  if (r.messageId) {
    r.message = meta.messages[r.messageId]
    delete r.message
  }
  if (r) {
    let reports = new Set()
    if (Cache.has(`report:${filepath}:${context.id}`)) {
      reports = Cache.get(`report:${filepath}:${context.id}`)
    }
    reports.add(JSON.stringify(r))
    Cache.set(`report:${filepath}:${context.id}`, reports)
  }
}

/**
 * @param {string} code
 * @param {string} sourcecode
 * @param {number} line
 */
function getDisabled (code, sourcecode, line) {
  const listDisabled = []
  const rules = Cache.get('rules')
  const rulesDisabled = Object.keys(rules).reduce((o, key) => ({ ...o, [key]: 'on' }), {})
  if (code) {
    const matches = [...code.matchAll(REGEX_COMMENTS)]
    if (matches.length > 0) {
      matches.forEach(match => {
        if (match) {
          const index = match.index
          match = match[0]
          if (match.includes('*/')) {
            match = match.split('*/')[0].replace('/*', '')
          } else if (match.includes('//')) {
            match = match.split('//')[1]
          }
          if (match) {
            match = match.trim()
          }
          ['disable', 'enable'].forEach(keyword => {
            const loc = sourcecode.getLocFromIndex(index)
            const disableType = match.split(' ')[0]
            let disableRules = match.split(`${disableType} `)[1]
            disableRules = disableRules
              ? disableRules.split(',').map(rule => rule.trim())
              : Object.keys(rules).map(rule => `@sap/cds/${rule}`)
            let comment = {}
            if ([`eslint-${keyword}`, `eslint-${keyword}-line`, `eslint-${keyword}-next-line`].includes(disableType)) {
              comment = disableType.includes('-next-line')
                ? {
                  lineComment: loc.line,
                  lineDisabled: loc.line + 1,
                  rules: disableRules,
                  type: keyword
                }
                : {
                  lineComment: loc.line,
                  lineDisabled: loc.line,
                  rules: disableRules,
                  type: keyword
                }
              if (!disableType.includes('-line')) {
                comment.lineDisabled = 'EOF'
              }
            }
            listDisabled.push(comment)
          })
        }
      })
      for (const el of listDisabled.filter(
        d => d.lineComment < line && (d.lineDisabled === 'EOF' || d.lineDisabled === line)
      )) {
        if (el.lineDisabled === 'EOF') {
          el.lineDisabled = getLastLine(code)
        }
        if (el.rules) {
          el.rules.forEach(rule => {
            if (el.type === 'disable') {
              rulesDisabled[rule] = 'off'
            } else if (el.type === 'enable') {
              rulesDisabled[rule] = 'on'
            }
          })
        }
      }
    }
  }
  return rulesDisabled
}

/**
 * @param {string} code
 */
function getLastLine (code) {
  const lines = typeof code === 'string' ? SourceCode.splitLines(code) : code
  return lines.length - 1
}

/**
 * @param {string} file
 */
function resolveFilePath (file) {
  return path.isAbsolute(file) ? file : path.join(Cache.get('rootpath'), file)
}
