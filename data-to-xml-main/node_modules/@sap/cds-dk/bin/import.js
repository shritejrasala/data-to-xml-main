module.exports = Object.assign(_import, {
    _name: 'import',
    options: ['--out', '--as', '--name', '--include-namespaces', '--from', '--config', '--destination'],
    flags: ['--dry', '--force', '--no-copy', '--no-save', '--keep-namespace', '--beta'],
    shortcuts: ['-o', '-as', '-n', '-ns', undefined, '-c', undefined, '-', '-f'],
    help: `
# SYNOPSIS

    *cds import* <source> [<options>]

    Imports the given source and converts it to CSN.
    Currently following file formats are supported.
    - EDMX and XML for OData V2 and V4
    - JSON for OpenAPI and AsyncAPI

    Without any options the source is copied to ./srv/external and the csn
    output written next to it. Finally it will add an entry for the imported
    service to package.json#cds.requires.


# OPTIONS

    *--no-copy*
        Skips copying to ./srv/external.

    *--no-save*
        Skips updating ./package.json.

    *-o | --out* <filename>
        Skips copying to ./srv/external and writes to the specified location.

    *- | --dry*
        Writes the converted csn to stdout only.

    *-as | --as <output_file_format>*
        Converts the input file into one of these supported formats "cds", "csn"
        or "json".

    *-f | --force*
        Forcefully overwrites the contents in the CDS file and updates the
        checksum

    *--from*
        Imports the model from the one of the given options "edmx", "openapi" or
        "asyncapi".

    *-c | --config* <JSON Object>
        Adds the provided JSON Object as custom configuration data to the package.json.

    *--beta*
        Enables beta mode in cds import.
        - Populates default value for optional action and function parameters in the CSN or CDS.

    *--destination*
        Destination name under which the remote service can be reached.
        Not supported by import types "edmx", "openapi" or "asyncapi".

    *Below options are valid for OData only*

    *--keep-namespace*
        Keeps the original namespace from the edmx content instead of using
        the filename by default.

    *-ns | --include-namespaces <string_of_namespaces> or* "\x2A"
        Imports only entities matching to the given list of namespaces.
        For OData V2 attributes with the namespace "sap" & "m" are captured by
        default.

    *Below options are valid for RFC only*

    *-n | --name*
        The name of the module to be imported
        Requires valid system credentials as the import connects to the system to fetch the metadata.

# EXAMPLES

    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx
    cds import - ~/Downloads/API_BUSINESS_PARTNER.edmx
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --from edmx --as cds
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --include-namespaces "sap,c4c"
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --include-namespaces "\x2A"
    cds import ~/Downloads/Petstore_OpenAPI.json
    cds import ~/Downloads/Petstore_OpenAPI.json --from openapi
    cds import ~/Downloads/BookStore_AsyncAPI.json
    cds import ~/Downloads/BookStore_AsyncAPI.json --from asyncapi
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx -c "{\\"[production]\\":{\\"credentials\\":{\\"destination\\":\\"UI3_noauth\\",\\"path\\":\\"/sap/cap/odata\\"}}}"

`})
const messages = require('../lib/import/message').getMessages();
const common = require('../lib/import/common');
const cdsImport = require('../lib/index');

async function _import(args, options = {}) {
    let csn = '';
    let apiOptions = {};
    // preprocess
    let cwd = process.cwd();
    // process options
    await common.processOptions(options, apiOptions);

    const cds = require('../lib/cds')
    await cds.plugins

    let file
    let input
    if (!options.name) {
        file = Array.isArray(args) ? args[0] : args
        if (!file) return this.help('import')
        input = await common.preProcess(file, options, cwd);
    }

    // process - csn generation
    // if --from option is given, call api directly accordingly
    if (options.from) {
        if (!cdsImport.import.from[options.from]) {
            // the required plugin might not be installed, e.g. rfc importer
            throw messages.UNSUPPORTED_FROM_OPTION;
        }
        csn = await cdsImport.import.from[options.from](input, apiOptions);
    } else {
        csn = await cdsImport.import(input, apiOptions);
    }

    // reads the file version
    options.inputFileKind = apiOptions.odataVersion ? apiOptions.odataVersion : apiOptions.inputFileKind;

    // postprocess
    return await common.postProcess(apiOptions.file ?? file, options, csn, cwd);
}
